#Imports
from haversine import haversine # for distance calculation
import pants # for IA intelligence
import csv # to parse information
import os, sys # to execute system calls
import requests # to make HTTP requests to GOOGLE APIs
from urllib.parse import quote # to parse parameters for the "request" module
import base64 # to save the HTML template in the code
import re # to manipulate Regular Expressions

#Constants
def strIsTrue(str):
	return str.lower() in ['true', '1', 't', 'y', 'yes', 'yeah', 'yup', 'certainly', 'uh-huh']

CSV_FILENAME = os.getenv('CSV_FILENAME', 'open_pubs.csv') # data file
USE_MILES_UNIT = strIsTrue(os.getenv('USE_MILES_UNIT', "false")) #if false, will use Kilometers

try:
	GOOGLE_API_TOKEN = os.environ['GOOGLE_API_TOKEN']
except:
	print("You need to define the GOOGLE_API_TOKEN env variable to use GOOGLE GEOLOC API")
	sys.exit(1)

NUMBER_NODES = int(os.getenv('NUMBER_NODES', 150)) # define the number of nodes to use in the process ( to reduce time calculation for tests )

MAP_CENTER = strIsTrue(os.getenv('MAP_CENTER', "false")) # If true, the map will be centered around the nodes positions, else it will focus on the first node.

nodes = []

def calcul_distance(a, b):
	return haversine(a, b, miles=USE_MILES_UNIT) # we make the calculation with latitude and longitude coordonees

# File loading	

if not os.path.exists("./data"):
    os.makedirs("./data") # We create a data folder to save the information generated by the script 

if not os.path.isfile("./data/clean.csv"): # We check if the temporary file exists
	with open(CSV_FILENAME, 'r') as csvfile:
		print("Starting csv load and cleaning")
		reader = csv.reader(csvfile, doublequote=True, skipinitialspace=True) # We read the csv
		next(reader, None)
		for index, row in enumerate(reader): # We loop oven the rows
			vals = (None, None) 
			if row[8] == "": # If we made a wrong parsing on the csv, we do it again with some other way ( unstable )
				with open(CSV_FILENAME, 'r') as secondssvfile:
					for i, line in enumerate(secondssvfile):
						if i == index:
							r = csv.reader([line], doublequote=True, skipinitialspace=True)
							row = next(r)
							break
			# Check if the latitude or longitude is null, we make a request to the GEOLOC API
			if '\\N' in row[-3:][:2]:
				res = requests.get("https://maps.googleapis.com/maps/api/geocode/json?key={}&address={}".format(GOOGLE_API_TOKEN, quote(row[2]))).json() # We parse the parameters with "quote" to escape the values
				if res['status'] != 'OK': # If we had some trouble with the API
					if res['status'] == 'ZERO_RESULTS':
						print("Can't find the location for {} on ".format(row[2], index)) # we display some information
						print(row)
					else:
						print(res) # or we display the error
				else: 
					res = res['results'][0]['geometry']['location'] # If we got a result, we parse it and we add it to the list
					vals = (float(res['lat']), float(res['lng']))
			else:
				vals = (float(row[6]), float(row[7]))
			if None not in vals:
				nodes.append(vals)
	print("{} nodes found".format(len(nodes)))
	print("Finished csv load")

	nodes = [node for i, node in enumerate(nodes) if NUMBER_NODES <= 0 or i < NUMBER_NODES] # We apply our filter on the nodes list
	nodes = list(set(nodes)) # We "clean" the nodes to remove any double value
	print("{} clean nodes found".format(len(nodes)))
	
	print("Writing temp file")
	with open('data/clean.csv', 'w', newline='') as csvfile: # We create a temporary file to avoid doing the reserch and the API calls multiple times.
		spamwriter = csv.writer(csvfile, quoting=csv.QUOTE_MINIMAL) 
		rows = [list(node) for node in nodes]
		spamwriter.writerows(rows)
	print("Finished writing temp file")
else:
	print("Temp file found, reading it") # If we find the temporary file, we load it in the nodes list
	with open('./data/clean.csv', 'r') as csvfile:
		reader = csv.reader(csvfile, doublequote=True, skipinitialspace=True)
		for row in reader:
			vals = (float(row[0]), float(row[1]))
			nodes.append(vals)
	nodes = [node for i, node in enumerate(nodes) if NUMBER_NODES <= 0 or i < NUMBER_NODES] # We apply the filter ( no need to check for doubles, as this file is generated by the script
	print("Temp file load finished")

#Calculation

print("Creating world")
world = pants.World(nodes, calcul_distance) #  We create the environement for the ant system
print("Finished creating world")

print("Creating solver")
solver = pants.Solver() # We create the solver
print("Finished creating solver")

print("Starting solving world")
solutions = solver.solutions(world) # We generate our solutions
best = float("inf")
bestSolution = None
for currSolution in solutions: # We try to find wich solution has the lower distance in total
	if currSolution.distance < best:
		best = currSolution.distance
		solution = currSolution # We keep the solution

print("Finished solving world")

print("the best distance is {} {}".format(round(best, 3), "miles" if USE_MILES_UNIT else "km")) # We display the distance

print("Generating the map")

# We saved a HTML template in Base64, all the variables are allready managed in the file
htmlTemplate = "PCFET0NUWVBFIGh0bWw+DQo8aHRtbD4NCiAgPGhlYWQ+DQogICAgPG1ldGEgbmFtZT0idmlld3BvcnQiIGNvbnRlbnQ9ImluaXRpYWwtc2NhbGU9MS4wLCB1c2VyLXNjYWxhYmxlPW5vIj4NCiAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+DQogICAgPHRpdGxlPlNpbXBsZSBQb2x5bGluZXM8L3RpdGxlPg0KICAgIDxzdHlsZT4NCiAgICAgICNtYXAgew0KICAgICAgICBoZWlnaHQ6IDEwMCU7DQogICAgICB9DQogICAgICBodG1sLCBib2R5IHsNCiAgICAgICAgaGVpZ2h0OiAxMDAlOw0KICAgICAgICBtYXJnaW46IDA7DQogICAgICAgIHBhZGRpbmc6IDA7DQogICAgICB9DQogICAgPC9zdHlsZT4NCiAgPC9oZWFkPg0KICA8Ym9keT4NCiAgICA8ZGl2IGlkPSJtYXAiPjwvZGl2Pg0KICAgIDxzY3JpcHQ+DQoJY29uc3QgdmFsdWVzID0ge30gDQoJY29uc3QgdmFsdWVzTGVuZ2h0ID0gdmFsdWVzLmxlbmd0aA0KCWxldCBjdXJyZW50UG9pbnQgPSAwDQoJbGV0IGN1cnJlbnRab29tID0gLTENCglsZXQgbWFwID0gbnVsbA0KCQ0KCWZ1bmN0aW9uIGluaXRNYXAgKCl7DQoJCW1hcCA9IG5ldyBnb29nbGUubWFwcy5NYXAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hcCcpLCB7DQoJCQl6b29tOiB7fSAsDQoJCQljZW50ZXI6IHtsYXQ6IHt9ICwgbG5nOiB7fSB9LA0KCQkJbWFwVHlwZUlkOiAndGVycmFpbicNCiAgICAgICAgfSkNCgkJDQoJCWNvbnN0IGZsaWdodFBsYW5Db29yZGluYXRlcyA9IHZhbHVlcy5tYXAodiA9PiAoe2xhdDogdlswXSwgbG5nOiB2WzFdfSkpDQogICAgICAgIGNvbnN0IGZsaWdodFBhdGggPSBuZXcgZ29vZ2xlLm1hcHMuUG9seWxpbmUoew0KICAgICAgICAgIHBhdGg6IGZsaWdodFBsYW5Db29yZGluYXRlcywNCiAgICAgICAgICBnZW9kZXNpYzogdHJ1ZSwNCiAgICAgICAgICBzdHJva2VDb2xvcjogJyNGRjAwMDAnLA0KICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IDEuMCwNCiAgICAgICAgICBzdHJva2VXZWlnaHQ6IDINCiAgICAgICAgfSkNCg0KCWNvbnN0IG1hcmtlcnMgPSB2YWx1ZXMubWFwKCh2LGkpID0+IChuZXcgZ29vZ2xlLm1hcHMuTWFya2VyKHsNCiAgICAgICAgICBwb3NpdGlvbjoge2xhdDogdlswXSAsIGxuZzogdlsxXSB9LA0KICAgICAgICAgIG1hcDogbWFwLA0KICAgICAgICAgIHRpdGxlOiAoKHZhbHVlLCBpbmRleCwgdmFsdWVzKSA9PiB7fSApKHYsIGksICB2YWx1ZXMpDQogICAgICAgIH0pKSkNCg0KCQlmbGlnaHRQYXRoLnNldE1hcChtYXApDQogICAgfQ0KCQ0KCQ0KCWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGUpID0+IHsNCgkJc3dpdGNoKGUua2V5KSB7DQoJCQljYXNlICdoJzoNCgkJCQlhbGVydCgibiA9PiBuZXh0IHBvaW50XG5wID0+IHByZXZpb3VzIHBvaW50XG5nID0+IGdvIHRvIGEgc3BlY2lmaWMgcG9pbnRcbnogPT4gY2hhbmdlcyB0aGUgem9vbSBsZXZlbFxuaCA9PiBkaXNwbGF5IHRoaXMgaGVscCIpDQoJCQkJYnJlYWsNCgkJCWNhc2UgJ24nOg0KCQkJCWlmKCsrY3VycmVudFBvaW50ID4gdmFsdWVzTGVuZ2h0IC0gMSkgew0KCQkJCQljdXJyZW50UG9pbnQgPSAwDQoJCQkJfQ0KCQkJCWJyZWFrDQoJCQljYXNlICdwJzoNCgkJCQlpZigtLWN1cnJlbnRQb2ludCA8IDApIHsNCgkJCQkJY3VycmVudFBvaW50ID0gdmFsdWVzTGVuZ2h0IC0gMQ0KCQkJCX0NCgkJCQlicmVhaw0KCQkJY2FzZSAnZyc6DQoJCQkJY29uc3QgcmVwID0gKyh3aW5kb3cucHJvbXB0KGBQbGVhc2UgZW50ZXIgdGhlIHBvaW50IHlvdSB3YW50IHRvIGRpc3BsYXkuIChtYXggJHt2YWx1ZXNMZW5naHR9KWApKQ0KCQkJCWlmKE51bWJlci5pc0ludGVnZXIocmVwKSAmJiByZXAgPiAwICYmIHJlcCA8PSB2YWx1ZXNMZW5naHQpIHsNCgkJCQkJY3VycmVudFBvaW50ID0gcmVwIC0gMQ0KCQkJCX0NCgkJCQlicmVhaw0KCQkJY2FzZSAneic6DQoJCQkJY29uc3QgdmFscyA9IFs4LDEzLDE4XQ0KCQkJCWlmKCsrY3VycmVudFpvb20gPj0gdmFscy5sZW5ndGgpIHsNCgkJCQkJY3VycmVudFpvb20gPSAwDQoJCQkJfQ0KCQkJCW1hcC5zZXRab29tKHZhbHNbY3VycmVudFpvb21dKQ0KCQkJCWJyZWFrDQoJCX0NCgkJaWYoWyduJywncCcsJ2cnXS5pbmNsdWRlcyhlLmtleSkpIHsNCgkJCW1hcC5wYW5UbyhuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKC4uLnZhbHVlc1tjdXJyZW50UG9pbnRdKSkNCgkJfQ0KCX0pDQogICAgPC9zY3JpcHQ+DQogICAgPHNjcmlwdCBhc3luYyBkZWZlcg0KICAgIHNyYz0iaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2pzP2tleT17fSZjYWxsYmFjaz1pbml0TWFwIj4NCgk8L3NjcmlwdD4NCiAgPC9ib2R5Pg0KPC9odG1sPg0K"
htmlTemplate = base64.b64decode(htmlTemplate).decode("utf-8") # We decode the base64 string to get an UTF-8 string

moves = "[{}]".format(','.join(("[{},{}]".format(move[0], move[1])) for move in solution.tour)) # We generate a Javascript array to pass to the template
positionCenterCamera = [0,0] 
if MAP_CENTER: # We search for the map camera position in center
	for point in solution.tour:
		for i, latLong in enumerate(positionCenterCamera):
			positionCenterCamera[i] = latLong + point[i]
	movesLength = len(solution.tour)
	for i, latLong in enumerate(positionCenterCamera):
		positionCenterCamera[i] = latLong / movesLength

positionCamera = positionCenterCamera if MAP_CENTER else solution.tour[0] # If needed we will put the gmap camera
mapZoom = 7 if MAP_CENTER else 15 # If we use a centered camera, we zoom on the country ( 7 ) else we do it on the street ( 15 )

htmlTemplate = re.sub(r'([{}])(?![{} &])', r'\1\1', htmlTemplate) # We use a Regular Expression to transform "{" to "{{" to use the string into a str.format function
htmlTemplate = htmlTemplate.format(moves, mapZoom, positionCamera[0], positionCamera[1], "`Point numero ${index + 1} / ${values.length}`", GOOGLE_API_TOKEN) # We pass our needed parameters (JS array of moves, zoom, cameraX, cameraY, JS function body applied for each node (value, index, values), Google Token API)

with open('data/map.html', 'w', newline='') as html:
	html.write(htmlTemplate) # We generate ou Html page

print("Map generated")
print("Starting map")

os.system("start ./data/map.html") # We start the file on the system ( Windows way )

print("The script is finished") # We have finished our script
exit(0)
